---
title: AIåˆ†ææ¨¡å—å¢å¼º - æŠ€æœ¯è®¾è®¡
category: åŠŸèƒ½è§„æ ¼
tags: [AIåˆ†æ, è§†é¢‘è½¬å†™, çŸ¥è¯†åº“, æŠ–éŸ³è¿è¥]
created: 2026-02-20
version: v1.0
---

# AIåˆ†ææ¨¡å—å¢å¼º - æŠ€æœ¯è®¾è®¡

## ä¸€ã€ç³»ç»Ÿæ¶æ„

### 1.1 æ•´ä½“æ¶æ„

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å‰ç«¯ (React)                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  è§†é¢‘åˆ†æç»„ä»¶  â”‚  çŸ¥è¯†åº“ç®¡ç†  â”‚  å†…å®¹å¯¹è¯  â”‚  å†…å®¹åˆ›ä½œé›†æˆ        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚              â”‚            â”‚             â”‚
        â–¼              â–¼            â–¼             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      API Gateway (Express)                       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ /api/video-analysis â”‚ /api/knowledge-base â”‚ /api/content-chat   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        â”‚                    â”‚                     â”‚
        â–¼                    â–¼                     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        æœåŠ¡å±‚                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ VideoStructure  â”‚ VectorStore     â”‚ ContentChat                 â”‚
â”‚ AnalysisService â”‚ Service         â”‚ Service                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DocumentParser  â”‚ RAGService      â”‚ ContentIndex                â”‚
â”‚ Service         â”‚                 â”‚ Service                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚                 â”‚                       â”‚
         â–¼                 â–¼                       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        å­˜å‚¨å±‚                                    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ ChromaDB        â”‚ æ–‡ä»¶å­˜å‚¨        â”‚ MongoDB/å†…å­˜å­˜å‚¨            â”‚
â”‚ (å‘é‡æ•°æ®åº“)     â”‚ (æ–‡æ¡£æ–‡ä»¶)       â”‚ (å…ƒæ•°æ®)                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 æŠ€æœ¯é€‰å‹

| ç»„ä»¶ | æŠ€æœ¯é€‰å‹ | è¯´æ˜ |
|------|---------|------|
| å‘é‡æ•°æ®åº“ | ChromaDB | è½»é‡çº§æœ¬åœ°å‘é‡æ•°æ®åº“ï¼Œæ˜“äºé›†æˆ |
| Embedding | text-embedding-3-small | OpenAIåµŒå…¥æ¨¡å‹ï¼Œæ€§ä»·æ¯”é«˜ |
| æ–‡æ¡£è§£æ | pdf-parse + mammoth | æ”¯æŒPDFå’ŒWordæ–‡æ¡£ |
| LLM | å¤ç”¨ç°æœ‰multiAIService | æ”¯æŒå¤šæä¾›å•†åˆ‡æ¢ |
| æµå¼å“åº” | SSE (Server-Sent Events) | å®ç°å¯¹è¯æµå¼è¾“å‡º |

---

## äºŒã€è§†é¢‘ç»“æ„åŒ–åˆ†æè®¾è®¡

### 2.1 åˆ†ææµç¨‹

```
è§†é¢‘è½¬å½•æ–‡æœ¬
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ æ–‡æœ¬é¢„å¤„ç†       â”‚ â† æ¸…æ´—ã€åˆ†æ®µ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ç»“æ„è¯†åˆ«        â”‚ â† LLMåˆ†æ
â”‚ (å¼€å¤´é’©å­)       â”‚
â”‚ (é“ºå«å†…å®¹)       â”‚
â”‚ (æ ¸å¿ƒåŒ…è¢±)       â”‚
â”‚ (ç»“å°¾å¼•å¯¼)       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ èŠ‚å¥åˆ†æ        â”‚ â† æ—¶é—´åˆ†å¸ƒã€æƒ…æ„Ÿæ›²çº¿
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ çˆ†æ¬¾å…ƒç´ è¯†åˆ«     â”‚ â† å…³é”®è¯ã€æƒ…æ„Ÿè§¦å‘ç‚¹
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¼˜åŒ–å»ºè®®ç”Ÿæˆ     â”‚ â† åŸºäºåˆ†æç»“æœ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 æœåŠ¡æ¥å£è®¾è®¡

```javascript
// server/services/videoStructureAnalysisService.js

class VideoStructureAnalysisService {
  constructor() {
    this.multiAIService = require('./multiAIService');
  }

  /**
   * åˆ†æè§†é¢‘ç»“æ„
   * @param {string} transcript - è§†é¢‘è½¬å½•æ–‡æœ¬
   * @param {object} metadata - è§†é¢‘å…ƒæ•°æ®
   * @returns {Promise<object>} åˆ†æç»“æœ
   */
  async analyzeStructure(transcript, metadata = {}) {
    const structure = await this._identifyStructure(transcript);
    const rhythm = await this._analyzeRhythm(transcript, structure);
    const viralElements = await this._identifyViralElements(transcript, structure);
    const suggestions = await this._generateSuggestions(structure, rhythm, viralElements);
    
    return {
      structure,
      rhythm,
      viralElements,
      overallScore: this._calculateOverallScore(structure, rhythm, viralElements),
      viralPotential: this._assessViralPotential(viralElements),
      suggestions
    };
  }

  /**
   * è¯†åˆ«è§†é¢‘ç»“æ„
   */
  async _identifyStructure(transcript) {
    const prompt = `åˆ†æä»¥ä¸‹è§†é¢‘è½¬å½•æ–‡æœ¬ï¼Œè¯†åˆ«å…¶ç»“æ„ç»„æˆï¼š

è½¬å½•æ–‡æœ¬ï¼š
${transcript}

è¯·æŒ‰ä»¥ä¸‹ç»“æ„è¿›è¡Œåˆ†æï¼š
1. å¼€å¤´é’©å­ï¼ˆhookï¼‰ï¼šå‰3-5ç§’çš„å¸å¼•ç‚¹
2. é“ºå«å†…å®¹ï¼ˆsetupï¼‰ï¼šèƒŒæ™¯ä»‹ç»å’Œæƒ…å¢ƒé“ºå«
3. æ ¸å¿ƒåŒ…è¢±ï¼ˆclimaxï¼‰ï¼šé«˜æ½®æˆ–åè½¬éƒ¨åˆ†
4. ç»“å°¾å¼•å¯¼ï¼ˆctaï¼‰ï¼šäº’åŠ¨å¼•å¯¼æˆ–å…³æ³¨å¼•å¯¼

è¿”å›JSONæ ¼å¼ï¼š
{
  "hook": { "content": "å†…å®¹", "score": 0-100, "startTime": "00:00", "endTime": "00:05" },
  "setup": { "content": "å†…å®¹", "score": 0-100, "startTime": "00:05", "endTime": "00:20" },
  "climax": { "content": "å†…å®¹", "score": 0-100, "startTime": "00:20", "endTime": "00:45" },
  "cta": { "content": "å†…å®¹", "score": 0-100, "startTime": "00:45", "endTime": "00:50" }
}`;

    const response = await this.multiAIService.generateContent(prompt, {
      temperature: 0.3,
      maxTokens: 1000
    });

    return JSON.parse(response.content);
  }

  /**
   * åˆ†æèŠ‚å¥
   */
  async _analyzeRhythm(transcript, structure) {
    // åˆ†ææ–‡æœ¬é•¿åº¦åˆ†å¸ƒã€æƒ…æ„Ÿå˜åŒ–ã€ä¿¡æ¯å¯†åº¦
    const sections = Object.values(structure);
    const totalLength = transcript.length;
    
    return {
      pace: this._calculatePace(sections, totalLength),
      emotionalCurve: await this._analyzeEmotionalCurve(transcript),
      informationDensity: this._calculateInfoDensity(transcript),
      retentionPoints: await this._identifyRetentionPoints(transcript)
    };
  }

  /**
   * è¯†åˆ«çˆ†æ¬¾å…ƒç´ 
   */
  async _identifyViralElements(transcript, structure) {
    const prompt = `åˆ†æä»¥ä¸‹è§†é¢‘å†…å®¹ï¼Œè¯†åˆ«å¯èƒ½å¼•å‘ä¼ æ’­çš„çˆ†æ¬¾å…ƒç´ ï¼š

è½¬å½•æ–‡æœ¬ï¼š
${transcript}

ç»“æ„åˆ†æï¼š
${JSON.stringify(structure, null, 2)}

è¯·è¯†åˆ«ï¼š
1. æƒ…æ„Ÿè§¦å‘ç‚¹ï¼ˆå¼•å‘å…±é¸£çš„å†…å®¹ï¼‰
2. äº‰è®®ç‚¹ï¼ˆå¯èƒ½å¼•å‘è®¨è®ºçš„å†…å®¹ï¼‰
3. å®ç”¨ä»·å€¼ï¼ˆå¯¹è§‚ä¼—æœ‰å¸®åŠ©çš„å†…å®¹ï¼‰
4. å¨±ä¹å…ƒç´ ï¼ˆæœ‰è¶£æˆ–å¸å¼•äººçš„å†…å®¹ï¼‰
5. ä¼ æ’­åŠ¨æœºï¼ˆè§‚ä¼—åˆ†äº«çš„ç†ç”±ï¼‰

è¿”å›JSONæ ¼å¼ï¼š
{
  "emotionalTriggers": [],
  "controversyPoints": [],
  "practicalValue": [],
  "entertainmentElements": [],
  "sharingMotivations": [],
  "viralScore": 0-100
}`;

    const response = await this.multiAIService.generateContent(prompt, {
      temperature: 0.3,
      maxTokens: 800
    });

    return JSON.parse(response.content);
  }

  /**
   * ç”Ÿæˆä¼˜åŒ–å»ºè®®
   */
  async _generateSuggestions(structure, rhythm, viralElements) {
    const suggestions = [];
    
    // åŸºäºç»“æ„è¯„åˆ†ç”Ÿæˆå»ºè®®
    if (structure.hook.score < 70) {
      suggestions.push({
        type: 'hook',
        priority: 'high',
        suggestion: 'å¼€å¤´é’©å­å¸å¼•åŠ›ä¸è¶³ï¼Œå»ºè®®åœ¨å‰3ç§’åŠ å…¥æ›´å¼ºçš„å¸å¼•å…ƒç´ ',
        examples: ['ä½¿ç”¨æ‚¬å¿µå¼€å¤´', 'æå‡ºé—®é¢˜', 'å±•ç¤ºæƒŠäººæ•°æ®']
      });
    }
    
    if (structure.cta.score < 60) {
      suggestions.push({
        type: 'cta',
        priority: 'medium',
        suggestion: 'ç»“å°¾å¼•å¯¼ä¸å¤Ÿæ˜ç¡®ï¼Œå»ºè®®æ·»åŠ æ¸…æ™°çš„äº’åŠ¨å¼•å¯¼',
        examples: ['ç‚¹èµå…³æ³¨å¼•å¯¼', 'è¯„è®ºäº’åŠ¨å¼•å¯¼', 'åˆ†äº«è½¬å‘å¼•å¯¼']
      });
    }
    
    // åŸºäºçˆ†æ¬¾å…ƒç´ ç”Ÿæˆå»ºè®®
    if (viralElements.viralScore < 50) {
      suggestions.push({
        type: 'viral',
        priority: 'high',
        suggestion: 'çˆ†æ¬¾æ½œåŠ›è¾ƒä½ï¼Œå»ºè®®å¢åŠ ä¼ æ’­åŠ¨æœº',
        examples: ['æ·»åŠ äº‰è®®æ€§è§‚ç‚¹', 'å¢åŠ æƒ…æ„Ÿå…±é¸£ç‚¹', 'æä¾›å®ç”¨ä»·å€¼']
      });
    }
    
    return suggestions;
  }
}

module.exports = new VideoStructureAnalysisService();
```

### 2.3 APIè®¾è®¡

```javascript
// server/routes/videoAnalysis.js

const express = require('express');
const router = express.Router();
const videoStructureAnalysisService = require('../services/videoStructureAnalysisService');

/**
 * POST /api/video-analysis/structure
 * åˆ†æè§†é¢‘ç»“æ„
 */
router.post('/structure', async (req, res) => {
  try {
    const { transcript, metadata } = req.body;
    
    if (!transcript) {
      return res.status(400).json({
        success: false,
        message: 'ç¼ºå°‘è½¬å½•æ–‡æœ¬'
      });
    }
    
    const result = await videoStructureAnalysisService.analyzeStructure(transcript, metadata);
    
    res.json({
      success: true,
      data: result
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'åˆ†æå¤±è´¥: ' + error.message
    });
  }
});

/**
 * POST /api/video-analysis/batch
 * æ‰¹é‡åˆ†æè§†é¢‘
 */
router.post('/batch', async (req, res) => {
  try {
    const { videos } = req.body;
    
    const results = await Promise.all(
      videos.map(video => 
        videoStructureAnalysisService.analyzeStructure(video.transcript, video.metadata)
      )
    );
    
    res.json({
      success: true,
      data: results
    });
  } catch (error) {
    res.status(500).json({
      success: false,
      message: 'æ‰¹é‡åˆ†æå¤±è´¥: ' + error.message
    });
  }
});

module.exports = router;
```

---

## ä¸‰ã€ç§æœ‰çŸ¥è¯†åº“è®¾è®¡

### 3.1 æ¶æ„è®¾è®¡

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     çŸ¥è¯†åº“ç®¡ç†æœåŠ¡                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ æ–‡æ¡£ä¸Šä¼      â”‚  â”‚ æ–‡æ¡£è§£æ     â”‚  â”‚ å‘é‡åŒ–å­˜å‚¨   â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜         â”‚
â”‚         â”‚                â”‚                â”‚                 â”‚
â”‚         â–¼                â–¼                â–¼                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                   æ–‡æ¡£å¤„ç†æµæ°´çº¿                      â”‚   â”‚
â”‚  â”‚  ä¸Šä¼  â†’ è§£æ â†’ åˆ†å— â†’ å‘é‡åŒ– â†’ å­˜å‚¨                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                     å‘é‡å­˜å‚¨æœåŠ¡                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”‚
â”‚  â”‚ ChromaDB    â”‚  â”‚ Embedding   â”‚  â”‚ æ£€ç´¢æœåŠ¡     â”‚         â”‚
â”‚  â”‚ å‘é‡æ•°æ®åº“   â”‚  â”‚ API         â”‚  â”‚             â”‚         â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 å‘é‡å­˜å‚¨æœåŠ¡

```javascript
// server/services/vectorStoreService.js

const { ChromaClient } = require('chromadb');
const OpenAI = require('openai');

class VectorStoreService {
  constructor() {
    this.client = new ChromaClient({ path: 'http://localhost:8000' });
    this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.collection = null;
  }

  /**
   * åˆå§‹åŒ–é›†åˆ
   */
  async initialize(knowledgeBaseId) {
    this.collection = await this.client.getOrCreateCollection({
      name: `kb_${knowledgeBaseId}`,
      metadata: { description: `Knowledge base ${knowledgeBaseId}` }
    });
    return this.collection;
  }

  /**
   * ç”Ÿæˆæ–‡æœ¬åµŒå…¥
   */
  async generateEmbedding(text) {
    const response = await this.openai.embeddings.create({
      model: 'text-embedding-3-small',
      input: text
    });
    return response.data[0].embedding;
  }

  /**
   * æ·»åŠ æ–‡æ¡£
   */
  async addDocuments(documents) {
    const ids = documents.map(d => d.id);
    const texts = documents.map(d => d.content);
    const embeddings = await Promise.all(
      texts.map(text => this.generateEmbedding(text))
    );
    const metadatas = documents.map(d => ({
      source: d.source,
      page: d.page,
      knowledgeBaseId: d.knowledgeBaseId
    }));

    await this.collection.add({
      ids,
      embeddings,
      documents: texts,
      metadatas
    });
  }

  /**
   * ç›¸ä¼¼åº¦æ£€ç´¢
   */
  async similaritySearch(query, k = 5) {
    const queryEmbedding = await this.generateEmbedding(query);
    
    const results = await this.collection.query({
      queryEmbeddings: [queryEmbedding],
      nResults: k
    });

    return results.documents[0].map((doc, i) => ({
      content: doc,
      metadata: results.metadatas[0][i],
      distance: results.distances[0][i]
    }));
  }

  /**
   * åˆ é™¤æ–‡æ¡£
   */
  async deleteDocuments(ids) {
    await this.collection.delete({ ids });
  }

  /**
   * åˆ é™¤é›†åˆ
   */
  async deleteCollection() {
    await this.client.deleteCollection({ name: this.collection.name });
  }
}

module.exports = new VectorStoreService();
```

### 3.3 æ–‡æ¡£è§£ææœåŠ¡

```javascript
// server/services/documentParserService.js

const pdf = require('pdf-parse');
const mammoth = require('mammoth');
const fs = require('fs').promises;

class DocumentParserService {
  /**
   * è§£ææ–‡æ¡£
   */
  async parse(filePath, fileType) {
    const buffer = await fs.readFile(filePath);
    
    switch (fileType) {
      case 'pdf':
        return this.parsePDF(buffer);
      case 'docx':
        return this.parseDOCX(buffer);
      case 'txt':
        return this.parseTXT(buffer);
      case 'md':
        return this.parseMarkdown(buffer);
      default:
        throw new Error(`ä¸æ”¯æŒçš„æ–‡ä»¶ç±»å‹: ${fileType}`);
    }
  }

  /**
   * è§£æPDF
   */
  async parsePDF(buffer) {
    const data = await pdf(buffer);
    return {
      text: data.text,
      pages: data.numpages,
      metadata: data.info
    };
  }

  /**
   * è§£æWordæ–‡æ¡£
   */
  async parseDOCX(buffer) {
    const result = await mammoth.extractRawText({ buffer });
    return {
      text: result.value,
      messages: result.messages
    };
  }

  /**
   * è§£æçº¯æ–‡æœ¬
   */
  async parseTXT(buffer) {
    return {
      text: buffer.toString('utf-8')
    };
  }

  /**
   * è§£æMarkdown
   */
  async parseMarkdown(buffer) {
    const text = buffer.toString('utf-8');
    return {
      text,
      headings: this.extractHeadings(text)
    };
  }

  /**
   * æ–‡æ¡£åˆ†å—
   */
  chunkText(text, options = {}) {
    const {
      chunkSize = 500,
      overlap = 50,
      separator = '\n\n'
    } = options;

    const chunks = [];
    const paragraphs = text.split(separator);
    let currentChunk = '';

    for (const paragraph of paragraphs) {
      if (currentChunk.length + paragraph.length > chunkSize) {
        if (currentChunk) {
          chunks.push(currentChunk.trim());
          // ä¿ç•™é‡å éƒ¨åˆ†
          const overlapText = currentChunk.slice(-overlap);
          currentChunk = overlapText + paragraph;
        } else {
          // å•ä¸ªæ®µè½è¶…è¿‡chunkSizeï¼ŒæŒ‰å¥å­åˆ†å‰²
          const sentences = paragraph.match(/[^ã€‚ï¼ï¼Ÿ.!?]+[ã€‚ï¼ï¼Ÿ.!?]+/g) || [paragraph];
          for (const sentence of sentences) {
            if (currentChunk.length + sentence.length > chunkSize) {
              if (currentChunk) chunks.push(currentChunk.trim());
              currentChunk = sentence;
            } else {
              currentChunk += sentence;
            }
          }
        }
      } else {
        currentChunk += separator + paragraph;
      }
    }

    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }

    return chunks;
  }

  /**
   * æå–æ ‡é¢˜
   */
  extractHeadings(markdown) {
    const headingRegex = /^(#{1,6})\s+(.+)$/gm;
    const headings = [];
    let match;

    while ((match = headingRegex.exec(markdown)) !== null) {
      headings.push({
        level: match[1].length,
        text: match[2]
      });
    }

    return headings;
  }
}

module.exports = new DocumentParserService();
```

---

## å››ã€å…¨åº“AIå¯¹è¯è®¾è®¡

### 4.1 å¯¹è¯æµç¨‹

```
ç”¨æˆ·é—®é¢˜
    â”‚
    â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ é—®é¢˜ç†è§£        â”‚ â† LLMåˆ†ææ„å›¾
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ è¯­ä¹‰æ£€ç´¢        â”‚ â† å‘é‡æ£€ç´¢ç›¸å…³å†…å®¹
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ä¸Šä¸‹æ–‡æ„å»º      â”‚ â† ç»„è£…æ£€ç´¢ç»“æœ
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ LLMç”Ÿæˆå›ç­”     â”‚ â† æµå¼è¾“å‡º
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚
         â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ å¼•ç”¨è¿½è¸ª        â”‚ â† æ ‡æ³¨æ¥æº
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 å¯¹è¯æœåŠ¡

```javascript
// server/services/contentChatService.js

const multiAIService = require('./multiAIService');
const vectorStoreService = require('./vectorStoreService');

class ContentChatService {
  constructor() {
    this.conversationHistory = new Map();
  }

  /**
   * å¯¹è¯
   */
  async chat(userId, question, options = {}) {
    const { knowledgeBaseId, stream = false } = options;

    // 1. è·å–å¯¹è¯å†å²
    const history = this.getHistory(userId);

    // 2. æ£€ç´¢ç›¸å…³å†…å®¹
    const relevantContent = await this.retrieveRelevantContent(
      question,
      knowledgeBaseId
    );

    // 3. æ„å»ºä¸Šä¸‹æ–‡
    const context = this.buildContext(relevantContent);

    // 4. ç”Ÿæˆå›ç­”
    const prompt = this.buildPrompt(question, context, history);

    if (stream) {
      return this.streamResponse(userId, prompt, relevantContent);
    }

    const response = await multiAIService.generateContent(prompt, {
      temperature: 0.7,
      maxTokens: 1000
    });

    // 5. æ›´æ–°å†å²
    this.updateHistory(userId, question, response.content);

    // 6. è¿”å›ç»“æœï¼ˆåŒ…å«å¼•ç”¨ï¼‰
    return {
      answer: response.content,
      sources: relevantContent.map(c => ({
        id: c.id,
        content: c.content.slice(0, 100) + '...',
        metadata: c.metadata
      }))
    };
  }

  /**
   * æ£€ç´¢ç›¸å…³å†…å®¹
   */
  async retrieveRelevantContent(question, knowledgeBaseId) {
    await vectorStoreService.initialize(knowledgeBaseId);
    return vectorStoreService.similaritySearch(question, 5);
  }

  /**
   * æ„å»ºæç¤ºè¯
   */
  buildPrompt(question, context, history) {
    return `ä½ æ˜¯ä¸€ä¸ªå†…å®¹åˆ›ä½œåŠ©æ‰‹ï¼Œå¯ä»¥åŸºäºç”¨æˆ·çš„å†å²å†…å®¹å›ç­”é—®é¢˜ã€‚

ç›¸å…³å†…å®¹ï¼š
${context}

å¯¹è¯å†å²ï¼š
${history.map(h => `ç”¨æˆ·: ${h.question}\nåŠ©æ‰‹: ${h.answer}`).join('\n')}

å½“å‰é—®é¢˜ï¼š${question}

è¯·åŸºäºç›¸å…³å†…å®¹å›ç­”é—®é¢˜ï¼Œå¹¶åœ¨å›ç­”ä¸­å¼•ç”¨æ¥æºã€‚å¦‚æœç›¸å…³å†…å®¹ä¸­æ²¡æœ‰ç­”æ¡ˆï¼Œè¯·è¯´æ˜ã€‚`;
  }

  /**
   * æ„å»ºä¸Šä¸‹æ–‡
   */
  buildContext(relevantContent) {
    return relevantContent
      .map((c, i) => `[${i + 1}] ${c.content}`)
      .join('\n\n');
  }

  /**
   * æµå¼å“åº”
   */
  async *streamResponse(userId, prompt, relevantContent) {
    const stream = await multiAIService.streamGenerate(prompt);

    let fullResponse = '';
    for await (const chunk of stream) {
      fullResponse += chunk;
      yield { type: 'chunk', content: chunk };
    }

    // æ›´æ–°å†å²
    this.updateHistory(userId, prompt.split('å½“å‰é—®é¢˜ï¼š')[1].split('\n')[0], fullResponse);

    // å‘é€æ¥æº
    yield {
      type: 'sources',
      sources: relevantContent.map(c => ({
        id: c.id,
        content: c.content.slice(0, 100) + '...',
        metadata: c.metadata
      }))
    };
  }

  /**
   * è·å–å†å²
   */
  getHistory(userId) {
    return this.conversationHistory.get(userId) || [];
  }

  /**
   * æ›´æ–°å†å²
   */
  updateHistory(userId, question, answer) {
    const history = this.getHistory(userId);
    history.push({ question, answer, timestamp: Date.now() });
    // ä¿ç•™æœ€è¿‘10è½®å¯¹è¯
    if (history.length > 10) {
      history.shift();
    }
    this.conversationHistory.set(userId, history);
  }
}

module.exports = new ContentChatService();
```

---

## äº”ã€å‰ç«¯ç»„ä»¶è®¾è®¡

### 5.1 è§†é¢‘åˆ†æç»„ä»¶

```jsx
// src/components/VideoStructureAnalysis.jsx

import React, { useState } from 'react';
import { useMutation } from '@tanstack/react-query';
import { Card, CardContent, CardHeader, CardTitle } from './ui/card';
import { Progress } from './ui/progress';
import { Badge } from './ui/badge';
import { Button } from './ui/button';
import api from '../lib/api';

const VideoStructureAnalysis = ({ transcript, onApplySuggestions }) => {
  const [analysis, setAnalysis] = useState(null);

  const analyzeMutation = useMutation({
    mutationFn: () => api.analyzeVideoStructure(transcript),
    onSuccess: (data) => setAnalysis(data)
  });

  const renderStructureSection = (name, data, icon) => (
    <div className="border rounded-lg p-4 space-y-2">
      <div className="flex items-center justify-between">
        <span className="font-medium flex items-center gap-2">
          {icon} {name}
        </span>
        <Badge variant={data.score >= 70 ? 'success' : data.score >= 50 ? 'warning' : 'destructive'}>
          {data.score}åˆ†
        </Badge>
      </div>
      <Progress value={data.score} />
      <p className="text-sm text-gray-600">{data.content}</p>
    </div>
  );

  return (
    <Card>
      <CardHeader>
        <CardTitle>è§†é¢‘ç»“æ„åˆ†æ</CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        {!analysis ? (
          <Button onClick={() => analyzeMutation.mutate()} loading={analyzeMutation.isPending}>
            å¼€å§‹åˆ†æ
          </Button>
        ) : (
          <>
            <div className="grid grid-cols-2 gap-4">
              {renderStructureSection('å¼€å¤´é’©å­', analysis.structure.hook, 'ğŸ£')}
              {renderStructureSection('é“ºå«å†…å®¹', analysis.structure.setup, 'ğŸ“–')}
              {renderStructureSection('æ ¸å¿ƒåŒ…è¢±', analysis.structure.climax, 'ğŸ’¥')}
              {renderStructureSection('ç»“å°¾å¼•å¯¼', analysis.structure.cta, 'ğŸ“¢')}
            </div>

            <div className="border-t pt-4">
              <h4 className="font-medium mb-2">ä¼˜åŒ–å»ºè®®</h4>
              <ul className="space-y-2">
                {analysis.suggestions.map((s, i) => (
                  <li key={i} className="flex items-start gap-2 text-sm">
                    <Badge variant={s.priority === 'high' ? 'destructive' : 'secondary'}>
                      {s.priority}
                    </Badge>
                    <span>{s.suggestion}</span>
                  </li>
                ))}
              </ul>
            </div>

            <Button onClick={() => onApplySuggestions(analysis.suggestions)}>
              åº”ç”¨ä¼˜åŒ–å»ºè®®
            </Button>
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default VideoStructureAnalysis;
```

---

## å…­ã€éƒ¨ç½²é…ç½®

### 6.1 ChromaDBéƒ¨ç½²

```yaml
# docker-compose.yml
version: '3.8'
services:
  chromadb:
    image: chromadb/chroma:latest
    ports:
      - "8000:8000"
    volumes:
      - chromadb_data:/chroma/chroma
    environment:
      - CHROMA_SERVER_HOST=0.0.0.0
      - CHROMA_SERVER_HTTP_PORT=8000

volumes:
  chromadb_data:
```

### 6.2 ç¯å¢ƒå˜é‡

```env
# .env
CHROMADB_URL=http://localhost:8000
OPENAI_API_KEY=sk-xxx
EMBEDDING_MODEL=text-embedding-3-small
```

---

## ä¸ƒã€æ€§èƒ½ä¼˜åŒ–

### 7.1 å‘é‡æ£€ç´¢ä¼˜åŒ–

- ä½¿ç”¨HNSWç´¢å¼•åŠ é€Ÿæ£€ç´¢
- æ‰¹é‡åµŒå…¥å‡å°‘APIè°ƒç”¨
- ç¼“å­˜å¸¸ç”¨æŸ¥è¯¢ç»“æœ

### 7.2 å¯¹è¯ä¼˜åŒ–

- æµå¼å“åº”æå‡ä½“éªŒ
- å¯¹è¯å†å²å‹ç¼©
- ä¸Šä¸‹æ–‡çª—å£ç®¡ç†

### 7.3 æ–‡æ¡£å¤„ç†ä¼˜åŒ–

- å¼‚æ­¥å¤„ç†å¤§æ–‡ä»¶
- å¢é‡ç´¢å¼•æ›´æ–°
- æ–‡æ¡£åˆ†å—å¹¶è¡Œå¤„ç†
